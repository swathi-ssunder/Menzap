package diy.net.menzap.service;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.util.Log;

import diy.net.menzap.middleware.MessageHandler;
import fi.tkk.netlab.dtn.scampi.applib.AppLib;
import fi.tkk.netlab.dtn.scampi.applib.AppLibLifecycleListener;
import fi.tkk.netlab.dtn.scampi.applib.MessageReceivedCallback;
import fi.tkk.netlab.dtn.scampi.applib.SCAMPIMessage;
import fi.tkk.netlab.net.Util;

import java.io.IOException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * <p> Service that maintains and AppLib connection to the router. Maintains a
 * timer that attempts to reconnect to the router on fixed period until
 * connection is established. </p> <p/> <p> Activities should bind and unbind to
 * the service as they become active, and use the API provided to interact with
 * the router. </p>
 *
 * @author teemuk
 */
public class AppLibService
        extends Service
        implements MessageReceivedCallback, AppLibLifecycleListener {
    /** SCAMPI pub/sub service name ({@value}). */
    public static final String MENZAP_TAG_SERVICE = "MenzapTags";
    /** Log tag for messages generated by this class ({@value}). */
    public static final String TAG = AppLibService.class.getSimpleName();
    /** Default lifetime for posted messages in seconds ({@value}). */
    public static final long MSG_LIFETIME = 60 * 60 * 24 * 14;
    /** Time to wait between trying to connect AppLib (milliseconds). */
    public static final long RECONNECT_PERIOD = 8000;


    //==========================================================================//
    // Definitions of the SCAMPIMessage fields
    //==========================================================================//
    public static final String MSG_TYPE_FIELD = "TYPE";
    public static final String MSG_SENDER_FIELD = "SENDER";
    public static final String MSG_TIMESTAMP_FIELD = "TIMESTAMP";
    public static final String MSG_UNIQUE_ID_FIELD = "ID";
    //==========================================================================//


    //==========================================================================//
    // Instance vars
    //==========================================================================//
    // Binder for activities
    private final IBinder binder = new AppLibService.AppLibBinder();
    // AppLib connection to the router
    private volatile AppLib appLib;
    // Task executor
    private ScheduledExecutorService scheduledExecutor;

    private MessageHandler msgHandler;
    //==========================================================================//


    //==========================================================================//
    // API
    //==========================================================================//

    /**
     * Attempts to publish the message using the router. Returns <code>true</code>
     * if successful, <code>false</code> otherwise. Publishing may fail if there
     * is no current API connection to a router (e.g., the router is not currently
     * running)
     *
     * @return <code>true</code> if successful, <code>false</code> otherwise.
     */
    public boolean publish(SCAMPIMessage msg) {

        if ( this.appLib != null ) {
            try {
                this.appLib.publish( msg, MENZAP_TAG_SERVICE );
            } catch ( InterruptedException e ) {
                // We just eat the exception here since it only occurs when we
                // interrupt the appLib ourselves.
                Util.log_error( "Failed to publish (" + e.getMessage() + ")." );
                Log.d("CUSTOM IN PUBLISH --", "error in publishing");
                return false;
            }
            Log.d("CUSTOM IN PUBLISH --", "published successfully");
            return true;
        }

        Log.d("CUSTOM IN PUBLISH --", "applib is null");
        return false;
    }
    //==========================================================================//


    //==========================================================================//
    // Lifecycle
    //==========================================================================//
    @Override
    public IBinder onBind( Intent intent ) {
        Log.d( TAG, "onBind()" );

        return this.binder;
    }

    @Override
    public void onCreate() {
        super.onCreate();

        // Create timer
        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();

        // Create message handler
        this.msgHandler = new MessageHandler(this);

        // Create AppLib and try to connect.
        // - if connecting fails the lifecycle callback will schedule another try
        // using the timer
        this.appLib = this.getAppLib();
        this.appLib.start();
        // Must go through the executor or Android whines about networking in
        // main loop.
        this.scheduleConnect( 0, TimeUnit.MILLISECONDS );

        Log.d( TAG, "onCreate()" );
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        this.scheduledExecutor.shutdownNow();

        this.appLib.stop();

        Log.d( TAG, "onDestroy()" );
    }

    @Override
    public void onRebind( Intent intent ) {
        super.onRebind( intent );

        Log.d( TAG, "onRebind()" );
    }

    @Override
    public int onStartCommand( Intent intent, int flags, int startId ) {
        super.onDestroy();

        Log.d( TAG, "onStartCommand()" );

        return START_STICKY;
    }
    //==========================================================================//


    //==========================================================================//
    // Private
    //==========================================================================//
    private void handleIncomingMessage( SCAMPIMessage msg )
            throws IOException {
        Log.d( TAG, "Handling incoming message." );

        // Precondition check
        boolean hasType = msg.hasString( MSG_TYPE_FIELD );
        boolean hasSender = msg.hasString( MSG_SENDER_FIELD );
        boolean hasTimestamp = msg.hasInteger( MSG_TIMESTAMP_FIELD );
        boolean hasId = msg.hasInteger( MSG_UNIQUE_ID_FIELD );
        if ( !hasType || !hasSender || !hasTimestamp || !hasId ) {
            throw new IOException( "Invalid message, missing required field(s). ("
                    + "type: " + hasType + ", sender: " + hasSender
                    + ", timestamp: " + hasTimestamp + ", id: " +
                    hasId + ")" );
        }

        this.msgHandler.handleIncomingMessage(msg);
    }

    //==========================================================================//


    //==========================================================================//
    // AppLib handling
    //==========================================================================//
    private AppLib getAppLib() {
        AppLib applib = new AppLib();

        // Lifecycle listener
        applib.addLifecycleListener( this );

        // Setup subscription to the
        applib.addMessageReceivedCallback( MENZAP_TAG_SERVICE, this );
        try {
            applib.subscribe( MENZAP_TAG_SERVICE );
        } catch ( InterruptedException e ) {
            Log.d( TAG, "Subscribing failed (" + e.getMessage() + ")" );
        }

        return applib;
    }


    //--------------------------------------------------------------------------//
    // LifecycleListener
    //--------------------------------------------------------------------------//
    @Override
    public void onConnected( String scampiId ) {
        Log.d( TAG, "AppLib connected: " + scampiId );

    }

    @Override
    public void onDisconnected() {
        Log.d( TAG, "AppLib disconnected" );
        this.scheduleConnect( RECONNECT_PERIOD, TimeUnit.MILLISECONDS );
    }

    @Override
    public void onConnectFailed() {
        Log.d( TAG, "AppLib connect failed" );
        this.scheduleConnect( RECONNECT_PERIOD, TimeUnit.MILLISECONDS );
    }

    @Override
    public void onStopped() {
        Log.d( TAG, "AppLib stopped" );
        // Terminal state
    }

    //--------------------------------------------------------------------------//
    // MessageReceivedCallback
    //--------------------------------------------------------------------------//
    @Override
    public void messageReceived( SCAMPIMessage scampiMessage, String service ) {
        Log.d( TAG, "AppLib message received." );

        if ( service.equals( MENZAP_TAG_SERVICE ) ) {
            try {
                this.handleIncomingMessage( scampiMessage );
            } catch ( Exception e ) {
                Log.e( TAG, "Invalid SCAMPI message (" + e.getMessage() + ")" +
                        ".", e );
            }
        } else {
            Log.d( TAG, "Received message published to an incorrect service '"
                    + service + "'." );
        }

        scampiMessage.close();
    }
    //==========================================================================//


    //==========================================================================//
    // Reconnect timer
    //==========================================================================//
    // Reconnect timer attempts to connect an AppLib instance to the router on
    // some fixed period. This allows the router process to be closed down
    // and brought up with the AppLibService connecting to it when it's
    // available.
    //--------------------------------------------------------------------------//
    private void scheduleConnect( long delay, TimeUnit unit ) {
        Log.d( TAG, "Scheduling applib connect in: " + delay + " " + unit );
        this.scheduledExecutor.schedule( new ReconnectTask( this.appLib ),
                delay, unit );
    }

    private static class ReconnectTask
            implements Runnable {
        private final AppLib appLib;

        public ReconnectTask( AppLib appLib ) {
            this.appLib = appLib;
        }

        @Override
        public void run() {
            AppLib.State state = this.appLib.getLifecycleState();
            if ( state == AppLib.State.IDLE
                    || state == AppLib.State.NEW ) {
                Log.d( TAG, "Trying to connect appLib" );
                this.appLib.connect();
            } else {
                Log.d( TAG, "Can't connect, lifecycle state: " + state );
            }
        }
    }


    //==========================================================================//


    //==========================================================================//
    // Binder
    //==========================================================================//
    public class AppLibBinder
            extends Binder {
        public AppLibService getService() {
            return AppLibService.this;
        }
    }
    //==========================================================================//
}
